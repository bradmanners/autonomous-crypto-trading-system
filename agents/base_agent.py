"""
Base Agent Class
All trading system agents inherit from this base class
"""
from abc import ABC, abstractmethod
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from enum import Enum
import logging
import json
from prometheus_client import Counter, Gauge, Histogram
from sqlalchemy import text

from config.config import config
from utils.database import db, redis_client


class AgentType(Enum):
    """Agent type enumeration"""
    DATA_COLLECTOR = "data_collector"
    ANALYST = "analyst"
    ORCHESTRATOR = "orchestrator"
    EXECUTOR = "executor"
    IMPROVEMENT = "improvement"
    META = "meta"


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


class SignalStrength(Enum):
    """Signal strength/confidence levels"""
    VERY_WEAK = 0.2
    WEAK = 0.4
    MODERATE = 0.6
    STRONG = 0.8
    VERY_STRONG = 1.0


class BaseAgent(ABC):
    """
    Base class for all trading system agents

    Provides common functionality:
    - Database and cache access
    - Logging and monitoring
    - Signal generation and storage
    - State management
    - Error handling
    """

    def __init__(
        self,
        agent_name: str,
        agent_type: AgentType,
        version: str = "1.0.0"
    ):
        """
        Initialize base agent

        Args:
            agent_name: Unique name for this agent
            agent_type: Type of agent (from AgentType enum)
            version: Agent version number
        """
        self.agent_name = agent_name
        self.agent_type = agent_type
        self.version = version
        self.start_time = datetime.now(timezone.utc)

        # Setup logging
        self.logger = logging.getLogger(f"agent.{agent_name}")
        self.logger.info(f"Initializing agent: {agent_name} (v{version})")

        # Database and cache
        self.db = db
        self.redis = redis_client

        # Prometheus metrics
        self._setup_metrics()

        # Agent state
        self.is_running = False
        self.error_count = 0
        self.success_count = 0
        self.last_run = None

        # Load agent configuration from cache if exists
        self._load_state()

    def _setup_metrics(self):
        """Setup Prometheus metrics for this agent"""
        agent_label = self.agent_name.lower().replace(" ", "_")

        self.metrics = {
            'executions': Counter(
                f'agent_{agent_label}_executions_total',
                f'Total executions of {self.agent_name}'
            ),
            'errors': Counter(
                f'agent_{agent_label}_errors_total',
                f'Total errors in {self.agent_name}'
            ),
            'duration': Histogram(
                f'agent_{agent_label}_duration_seconds',
                f'Execution duration of {self.agent_name}'
            ),
            'signals_generated': Counter(
                f'agent_{agent_label}_signals_total',
                f'Total signals generated by {self.agent_name}'
            ),
            'is_running': Gauge(
                f'agent_{agent_label}_running',
                f'Whether {self.agent_name} is currently running'
            )
        }

    def _load_state(self):
        """Load agent state from Redis cache"""
        try:
            state_key = f"agent_state:{self.agent_name}"
            state = self.redis.get_json(state_key)

            if state:
                self.error_count = state.get('error_count', 0)
                self.success_count = state.get('success_count', 0)
                self.last_run = datetime.fromisoformat(state['last_run']) if state.get('last_run') else None
                self.logger.info(f"Loaded state: {state}")
        except Exception as e:
            self.logger.warning(f"Could not load state: {e}")

    def _save_state(self):
        """Save agent state to Redis cache"""
        try:
            state_key = f"agent_state:{self.agent_name}"
            state = {
                'agent_name': self.agent_name,
                'agent_type': self.agent_type.value,
                'error_count': self.error_count,
                'success_count': self.success_count,
                'last_run': self.last_run.isoformat() if self.last_run else None,
                'version': self.version
            }
            self.redis.set_json(state_key, state, expiry=86400)  # 24 hours
        except Exception as e:
            self.logger.warning(f"Could not save state: {e}")

    @abstractmethod
    def run(self) -> Dict[str, Any]:
        """
        Main execution method - must be implemented by each agent

        Returns:
            Dict with execution results
        """
        pass

    @abstractmethod
    def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze data and generate insights - must be implemented by each agent

        Args:
            data: Input data to analyze

        Returns:
            Dict with analysis results
        """
        pass

    def execute(self) -> Dict[str, Any]:
        """
        Execute agent with error handling, monitoring, and state management

        Returns:
            Dict with execution results
        """
        self.is_running = True
        self.metrics['is_running'].set(1)
        self.metrics['executions'].inc()

        start_time = datetime.now(timezone.utc)
        result = {
            'agent_name': self.agent_name,
            'start_time': start_time.isoformat(),
            'success': False,
            'error': None
        }

        try:
            self.logger.info(f"Starting execution of {self.agent_name}")

            # Run the agent's main logic
            with self.metrics['duration'].time():
                run_result = self.run()

            # Update result
            result.update(run_result)
            result['success'] = True
            self.success_count += 1

            self.logger.info(f"Execution completed successfully")

        except Exception as e:
            self.logger.error(f"Execution failed: {e}", exc_info=True)
            self.error_count += 1
            self.metrics['errors'].inc()
            result['error'] = str(e)
            result['success'] = False

        finally:
            end_time = datetime.now(timezone.utc)
            duration = (end_time - start_time).total_seconds()

            result['end_time'] = end_time.isoformat()
            result['duration_seconds'] = duration

            self.last_run = end_time
            self.is_running = False
            self.metrics['is_running'].set(0)

            # Save state
            self._save_state()

            # Log execution to database
            self._log_execution(result)

        return result

    def save_signal(
        self,
        symbol: str,
        signal_type: SignalType,
        confidence: float,
        reasoning: str,
        metadata: Optional[Dict] = None
    ) -> int:
        """
        Save a trading signal to the database

        Args:
            symbol: Trading pair symbol (e.g., 'BTC/USDT')
            signal_type: Type of signal (BUY, SELL, HOLD, CLOSE)
            confidence: Confidence level (0.0 to 1.0)
            reasoning: Explanation for the signal
            metadata: Additional data (indicators, prices, etc.)

        Returns:
            Signal ID from database
        """
        try:
            with self.db.get_session() as session:
                query = text("""
                    INSERT INTO agent_signals (
                        agent_name,
                        symbol,
                        signal,
                        confidence,
                        reasoning,
                        metadata,
                        time
                    ) VALUES (
                        :agent_name,
                        :symbol,
                        :signal,
                        :confidence,
                        :reasoning,
                        :metadata,
                        :time
                    )
                    RETURNING id
                """)

                result = session.execute(query, {
                    'agent_name': self.agent_name,
                    'symbol': symbol,
                    'signal': signal_type.value,
                    'confidence': confidence,
                    'reasoning': reasoning,
                    'metadata': json.dumps(metadata or {}),
                    'time': datetime.now(timezone.utc)
                })

                signal_id = result.fetchone()[0]
                session.commit()

                self.metrics['signals_generated'].inc()
                self.logger.info(
                    f"Signal saved: {signal_type.value} {symbol} "
                    f"(confidence: {confidence:.2f}, id: {signal_id})"
                )

                # Also cache in Redis for fast access
                cache_key = f"signal:latest:{self.agent_name}:{symbol}"
                self.redis.set_json(cache_key, {
                    'signal_id': signal_id,
                    'signal_type': signal_type.value,
                    'confidence': confidence,
                    'timestamp': datetime.now(timezone.utc).isoformat()
                }, expiry=3600)

                return signal_id

        except Exception as e:
            self.logger.error(f"Failed to save signal: {e}")
            raise

    def get_latest_price(self, symbol: str) -> Optional[Dict[str, float]]:
        """
        Get the latest price data for a symbol

        Args:
            symbol: Trading pair symbol

        Returns:
            Dict with OHLCV data or None
        """
        try:
            # Try cache first
            cache_key = f"price:latest:{symbol}"
            cached = self.redis.get_json(cache_key)
            if cached:
                return cached

            # Get from database
            with self.db.get_session() as session:
                query = text("""
                    SELECT
                        open, high, low, close, volume,
                        time
                    FROM price_data
                    WHERE symbol = :symbol
                    ORDER BY time DESC
                    LIMIT 1
                """)

                result = session.execute(query, {'symbol': symbol}).fetchone()

                if result:
                    price_data = {
                        'open': float(result[0]),
                        'high': float(result[1]),
                        'low': float(result[2]),
                        'close': float(result[3]),
                        'volume': float(result[4]),
                        'timestamp': result[5].isoformat()
                    }

                    # Cache for 1 minute
                    self.redis.set_json(cache_key, price_data, expiry=60)
                    return price_data

        except Exception as e:
            self.logger.error(f"Failed to get latest price: {e}")

        return None

    def get_historical_prices(
        self,
        symbol: str,
        timeframe: str = '1h',
        limit: int = 100
    ) -> List[Dict[str, Any]]:
        """
        Get historical price data for a symbol

        Args:
            symbol: Trading pair symbol
            timeframe: Timeframe (1m, 5m, 15m, 1h, 4h, 1d)
            limit: Number of candles to retrieve

        Returns:
            List of OHLCV dicts
        """
        try:
            with self.db.get_session() as session:
                query = text("""
                    SELECT
                        time, open, high, low, close, volume
                    FROM price_data
                    WHERE symbol = :symbol
                        AND timeframe = :timeframe
                    ORDER BY time DESC
                    LIMIT :limit
                """)

                results = session.execute(query, {
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'limit': limit
                }).fetchall()

                return [
                    {
                        'timestamp': row[0].isoformat(),
                        'open': float(row[1]),
                        'high': float(row[2]),
                        'low': float(row[3]),
                        'close': float(row[4]),
                        'volume': float(row[5])
                    }
                    for row in results
                ]
        except Exception as e:
            self.logger.error(f"Failed to get historical prices: {e}")
            return []

    def _log_execution(self, result: Dict[str, Any]):
        """
        Log agent execution to database

        Args:
            result: Execution result dict
        """
        try:
            with self.db.get_session() as session:
                query = text("""
                    INSERT INTO agent_executions (
                        agent_name,
                        agent_type,
                        start_time,
                        end_time,
                        duration_seconds,
                        success,
                        error_message,
                        metadata
                    ) VALUES (
                        :agent_name,
                        :agent_type,
                        :start_time,
                        :end_time,
                        :duration,
                        :success,
                        :error,
                        :metadata
                    )
                """)

                session.execute(query, {
                    'agent_name': self.agent_name,
                    'agent_type': self.agent_type.value,
                    'start_time': result['start_time'],
                    'end_time': result['end_time'],
                    'duration': result['duration_seconds'],
                    'success': result['success'],
                    'error': result.get('error'),
                    'metadata': json.dumps({
                        k: v for k, v in result.items()
                        if k not in ['start_time', 'end_time', 'duration_seconds', 'success', 'error']
                    })
                })

                session.commit()
        except Exception as e:
            self.logger.warning(f"Failed to log execution: {e}")

    def get_status(self) -> Dict[str, Any]:
        """
        Get current status of the agent

        Returns:
            Dict with agent status information
        """
        uptime = (datetime.now(timezone.utc) - self.start_time).total_seconds()

        return {
            'agent_name': self.agent_name,
            'agent_type': self.agent_type.value,
            'version': self.version,
            'is_running': self.is_running,
            'uptime_seconds': uptime,
            'success_count': self.success_count,
            'error_count': self.error_count,
            'last_run': self.last_run.isoformat() if self.last_run else None,
            'error_rate': self.error_count / (self.success_count + self.error_count) if (self.success_count + self.error_count) > 0 else 0
        }

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} {self.agent_name} (v{self.version})>"
